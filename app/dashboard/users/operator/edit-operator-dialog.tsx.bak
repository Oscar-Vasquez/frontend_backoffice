"use client";

import { useState, useEffect, useRef }from "react";
import { getCookie }from "cookies-next";
import { zodResolver }from "@hookform/resolvers/zod";
import { useForm }from "react-hook-form";
import * as z from "zod";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogClose,
  DialogDescription,
}from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
}from "@/components/ui/form";
import { Input }from "@/components/ui/input";
import { Button }from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
}from "@/components/ui/select";
import { 
  ReloadIcon, 
  PersonIcon,
  EnvelopeClosedIcon,
  MobileIcon,
  IdCardIcon,
  CheckIcon,
  InfoCircledIcon,
  AvatarIcon,
  HomeIcon,
  CalendarIcon,
  UploadIcon,
  Cross2Icon,
}from "@radix-ui/react-icons";
import { toast }from "sonner";
import { motion }from "framer-motion";
import useThemeSettingsStore from "@/store/themeSettingsStore";
import { OperatorsService, Operator, UpdateOperatorDto }from "@/app/services/operators.service";
import { Calendar }from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger }from "@/components/ui/popover";
import { format }from "date-fns";
import { es }from "date-fns/locale/es";
import { Textarea }from "@/components/ui/textarea";
import { BranchesService }from "@/app/services/branches.service";
import { OperatorTypesService }from "@/app/services/operator-types.service";
import { Avatar, AvatarImage, AvatarFallback }from "@/components/ui/avatar";
import { Skeleton }from "@/components/ui/skeleton";
import { StorageService }from "@/app/services/storage.service";

const formSchema = z.object({
  email: z.string().email("Correo electr√≥nico inv√°lido"),
  firstName: z.string().min(2, "El nombre debe tener al menos 2 caracteres"),
  lastName: z.string().min(2, "El apellido debe tener al menos 2 caracteres"),
  phone: z.string().min(8, "El tel√©fono debe tener al menos 8 caracteres").optional(),
  photo: z.string().optional(),
  role: z.enum(["Admin", "Operator", "Manager", "Branch_Manager", "Programador"]).optional(),
  status: z.enum(["active", "inactive", "suspended"]).optional(),
  branch_id: z.string().min(1, "Debe seleccionar una sucursal").optional(),
  type_operator_id: z.string().min(1, "Debe seleccionar un tipo de operador").optional(),
  birthdate: z.date().optional(),
  address: z.string().optional(),
  gender: z.enum(["male", "female", "other", "prefer_not_to_say"]).optional(),
  identificationNumber: z.string().optional(),
  emergencyContact: z.string().optional(),
  notes: z.string().optional(),
});

type FormValues = z.infer<typeof formSchema>;

const roleColors = {
  Admin: "from-purple-500 to-indigo-500",
  Manager: "from-blue-500 to-cyan-500",
  Branch_Manager: "from-amber-500 to-orange-500",
  Operator: "from-emerald-500 to-teal-500",
  Programador: "from-pink-500 to-rose-500",
};

// Interfaces para los datos de sucursales y tipos de operadores
interface Branch {
  id: string;
  name: string;
}

interface OperatorType {
  id: string;
  name: string;
}

// Props para el componente
export interface EditOperatorDialogProps {
  operator: Operator;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSave?: (updatedOperator: Operator) => void;
}

export default function EditOperatorDialog({ 
  operator, 
  open, 
  onOpenChange,
  onSave
}: EditOperatorDialogProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [isDataLoading, setIsDataLoading] = useState(true);
  const [branches, setBranches] = useState<Branch[]>([]);
  const [operatorTypes, setOperatorTypes] = useState<OperatorType[]>([]);
  const [currentOperatorType, setCurrentOperatorType] = useState<string>("");
  const [currentStep, setCurrentStep] = useState(1);
  const themeColor = useThemeSettingsStore((state) => state.themeColor);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);

  // Mapear el rol del backend al formato del formulario
  const mapRoleToForm = (backendRole: string): "Admin" | "Manager" | "Branch_Manager" | "Operator" | "Programador" => {
    // Roles permitidos por el backend: "admin, manager, staff, guest, Contador, gerente_de_sucursal, programador"
    const roleMap: Record<string, "Admin" | "Manager" | "Branch_Manager" | "Operator" | "Programador"> = {
      // Admin
      "admin": "Admin",
      "administrator": "Admin",
      "administrador": "Admin",
      
      // Manager
      "manager": "Manager",
      "gerente": "Manager",
      "Contador": "Manager", // Mapear Contador a Manager
      
      // Branch Manager
      "gerente_de_sucursal": "Branch_Manager",
      "branch_manager": "Branch_Manager",
      "branchmanager": "Branch_Manager",
      
      // Programador (mantener como est√°)
      "programador": "Programador",
      
      // Operator/Staff
      "staff": "Operator",
      "operator": "Operator",
      "operador": "Operator",
      "guest": "Operator", // Mapear guest a Operator
    };
    
    // Si el rol viene en min√∫sculas pero el mapa est√° en may√∫sculas o viceversa
    const normalizedRole = backendRole?.toLowerCase();
    console.log(`Mapeando rol del backend "${backendRole}" (normalizado: "${normalizedRole}") a formulario: "${roleMap[normalizedRole] || "Operator"}"`);
    
    // Si el rol exacto es "programador", mantenerlo como Programador sin normalizar
    if (backendRole === "programador") {
      return "Programador";
    }
    
    // Si el rol no est√° en el mapa, usar Operator como valor por defecto
    return roleMap[normalizedRole] || "Operator";
  };

  // Mapear el rol del formulario al formato del backend
  const mapRoleToBackend = (formRole: string): string => {
    if (!formRole) return "staff"; // Valor por defecto si no hay rol
    
    // Estos valores DEBEN coincidir exactamente con los que el backend espera:
    // "admin, manager, staff, guest, Contador, gerente_de_sucursal, programador"
    const roleMap: Record<string, string> = {
      "Admin": "admin",
      "Manager": "manager", 
      "Branch_Manager": "gerente_de_sucursal",
      "Operator": "staff",  // Cambiado de "operator" a "staff" seg√∫n requisitos del backend
      "Programador": "programador" // A√±adido expl√≠citamente
    };
    
    // Comprobar si existe un mapeo para este rol
    if (!roleMap[formRole]) {
      console.warn(`‚ö†Ô∏è No existe mapeo para el rol "${formRole}", usando valor por defecto "staff"`);
      return "staff";
    }
    
    console.log(`Mapeando rol de formulario "${formRole}" a backend: "${roleMap[formRole]}"`);
    return roleMap[formRole];
  };

  // Configurar el formulario con los valores iniciales del operador
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: operator.email || "",
      firstName: operator.firstName || "",
      lastName: operator.lastName || "",
      phone: operator.phone || "",
      photo: operator.photo || undefined,
      role: mapRoleToForm(operator.role),
      status: (operator.status as "active" | "inactive" | "suspended") || "active",
      branch_id: operator.branchReference || undefined,
      // Nota: type_operator_id se cargar√° despu√©s
    },
  });

  // Cargar datos de sucursales y tipos de operadores
  useEffect(() => {
    const loadData = async () => {
      try {
        setIsDataLoading(true);
        // Cargar sucursales
        const branchesData = await BranchesService.getBranches();
        setBranches(branchesData.map(branch => ({
          id: branch.id,
          name: branch.name
        })));
        
        // Cargar tipos de operadores
        const typesData = await OperatorTypesService.getOperatorTypes();
        setOperatorTypes(typesData.map(type => ({
          id: type.id,
          name: type.name
        })));
        
        // Obtener detalles completos del operador para cargar todos los datos
        const operatorDetails = await OperatorsService.getOperator(operator.operatorId);
        console.log('üîç Detalles del operador para edici√≥n:', operatorDetails);
        
        // Verificar todas las posibles propiedades donde podr√≠a estar el ID del tipo de operador
        const typeOperatorId = operatorDetails.type_operator_id || 
                              operatorDetails.typeOperatorId || 
                              operatorDetails.typeOperator?.id;
        
        if (typeOperatorId) {
          console.log('‚úÖ Tipo de operador encontrado para el formulario:', typeOperatorId);
          form.setValue('type_operator_id', typeOperatorId);
          
          // Buscar el nombre del tipo de operador
          const typeOperator = typesData.find(type => type.id === typeOperatorId);
          if (typeOperator) {
            setCurrentOperatorType(typeOperator.name);
            console.log('üè∑Ô∏è Nombre del tipo de operador encontrado:', typeOperator.name);
          }
        }else {
          console.log('‚ö†Ô∏è No se encontr√≥ tipo de operador para el operador:', operator.operatorId);
        }
        
        // Asegurarse de que el branch_id est√© establecido
        if (operatorDetails.branchReference) {
          form.setValue('branch_id', operatorDetails.branchReference);
        }
        
        // Verificar y establecer el rol correctamente
        console.log('üëë Rol desde API:', operatorDetails.role);
        const mappedRole = mapRoleToForm(operatorDetails.role);
        console.log('üëë Rol mapeado para el formulario:', mappedRole);
        form.setValue('role', mappedRole);
        
        // Si hay foto, establecer la vista previa
        if (operatorDetails.photo) {
          setImagePreview(operatorDetails.photo);
        }
        
        // Diagnosticar formulario despu√©s de carga
        console.log('üìù Valores del formulario despu√©s de cargar:', form.getValues());
      }catch (error) {
        console.error("Error al cargar datos:", error);
        toast.error("Error al cargar datos necesarios");
      }finally {
        setIsDataLoading(false);
      }
    };
    
    if (open) {
      loadData();
    }
  }, [open, operator.operatorId, form]);

  // Manejar carga de imagen
  const handleImageChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validar tipo de archivo
    if (!file.type.startsWith('image/')) {
      toast.error("Por favor, selecciona un archivo de imagen v√°lido");
      return;
    }

    // Validar tama√±o (m√°ximo 5MB)
    const MAX_SIZE = 5 * 1024 * 1024; // 5MB
    if (file.size > MAX_SIZE) {
      toast.error("La imagen es demasiado grande. El tama√±o m√°ximo es 5MB");
      return;
    }

    try {
      setIsUploading(true);

      // Crear una imagen temporal para procesar
      const img = new Image();
      const objectUrl = URL.createObjectURL(file);
      
      // Usar una promesa para manejar la carga de la imagen
      const processedImageData = await new Promise<string>((resolve, reject) => {
        img.onload = () => {
          // Liberar la URL temporal
          URL.revokeObjectURL(objectUrl);
          
          // Definir las dimensiones m√°ximas
          const MAX_WIDTH = 800;
          const MAX_HEIGHT = 800;
          
          // Calcular las nuevas dimensiones manteniendo la proporci√≥n
          let width = img.width;
          let height = img.height;
          
          if (width > height) {
            if (width > MAX_WIDTH) {
              height = Math.round((height * MAX_WIDTH) / width);
              width = MAX_WIDTH;
            }
          }else {
            if (height > MAX_HEIGHT) {
              width = Math.round((width * MAX_HEIGHT) / height);
              height = MAX_HEIGHT;
            }
          }
          
          // Crear un canvas para redimensionar la imagen
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          
          // Dibujar la imagen redimensionada en el canvas
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);
          
          // Determinar la calidad de compresi√≥n basada en el tama√±o original
          let quality = 0.8; // Calidad por defecto (80%)
          
          if (file.size > 3 * 1024 * 1024) { // Si es mayor a 3MB
            quality = 0.6; // Reducir calidad a 60%
          }else if (file.size > 1 * 1024 * 1024) { // Si es mayor a 1MB
            quality = 0.7; // Reducir calidad a 70%
          }
          
          // Convertir a JPEG con la calidad determinada
          const imageData = canvas.toDataURL('image/jpeg', quality);
          
          // Verificar el tama√±o despu√©s de la compresi√≥n
          const base64WithoutPrefix = imageData.replace(/^data:image\/\w+;base64,/, '');
          const byteCharacters = atob(base64WithoutPrefix);
          const estimatedSize = byteCharacters.length;
          
          // Si a√∫n es demasiado grande, comprimir m√°s
          if (estimatedSize > 1024 * 1024) { // Si es mayor a 1MB despu√©s de la compresi√≥n
            console.log(`Imagen comprimida sigue siendo grande (${Math.round(estimatedSize/1024)}KB), comprimiendo m√°s...`);
            const extraCompressedData = canvas.toDataURL('image/jpeg', 0.5); // 50% de calidad
            resolve(extraCompressedData);
          }else {
            resolve(imageData);
          }
        };
        
        img.onerror = (error) => {
          URL.revokeObjectURL(objectUrl);
          reject(new Error("Error al cargar la imagen para procesar"));
        };
        
        // Iniciar carga de la imagen
        img.src = objectUrl;
      });
      
      // Establecer la imagen procesada
      setSelectedImage(processedImageData);
      setImagePreview(processedImageData);
      
      // Estimar el tama√±o de la imagen despu√©s del procesamiento
      const base64WithoutPrefix = processedImageData.replace(/^data:image\/\w+;base64,/, '');
      const byteCharacters = atob(base64WithoutPrefix);
      const estimatedSize = byteCharacters.length;
      
      console.log(`Imagen procesada: ${Math.round(estimatedSize/1024)}KB (Original: ${Math.round(file.size/1024)}KB)`);
      
      toast.success("Imagen cargada correctamente");
    }catch (error) {
      console.error("Error al procesar la imagen:", error);
      toast.error("Error al procesar la imagen");
    }finally {
      setIsUploading(false);
    }
  };

  const resetImage = () => {
    setSelectedImage(null);
    setImagePreview(operator.photo || null);
    form.setValue('photo', operator.photo || '');
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  // Funci√≥n para manejar el env√≠o del formulario
  const onSubmit = async (data: z.infer<typeof formSchema>) => {
    try {
      setIsLoading(true);

      // Log datos iniciales para diagn√≥stico
      console.log("Iniciando actualizaci√≥n, datos del formulario:", data);
      console.log("Operador actual:", operator);
      console.log("API URL:", process.env.NEXT_PUBLIC_API_URL);
      console.log("ID del operador:", operator.operatorId);

      // Preparar el DTO b√°sico para actualizar el operador
      const updateDto: UpdateOperatorDto = {
        email: data.email,
        firstName: data.firstName,
        lastName: data.lastName,
        phone: data.phone,
        type_operator_id: data.type_operator_id,
        branch_id: data.branch_id,
        role: mapRoleToBackend(data.role),
        status: data.status,
      };

      // Verificar si hay una imagen nueva que sea diferente a la actual
      if (selectedImage && operator.photo !== selectedImage) {
        console.log("Nueva imagen detectada, procesando...");
        
        try {
          // Convertir la imagen base64 en un Blob para subirla
          console.log("Convirtiendo imagen a blob...");
          const base64Response = await fetch(selectedImage);
          const blob = await base64Response.blob();
          
          // Crear un objeto File con un nombre temporal
          const fileName = `operator_${operator.operatorId}_${Date.now()}.jpg`;
          const file = new File([blob], fileName, { 
            type: 'image/jpeg' 
          });
          
          console.log("Archivo creado:", file.name, "Tama√±o:", file.size);
          
          // Cargar el m√≥dulo de supabase directamente
          const supabaseModule = await import('@/lib/supabase');
          const { supabase }= supabaseModule;
          
          // Generar un nombre √∫nico para el archivo
          const fileExt = file.name.split('.').pop();
          const filePath = `operators/${Math.random().toString(36).substring(2, 15)}_${Date.now()}.${fileExt}`;
          const bucket = 'workexpressimagedata';
          
          // Variable para almacenar la ruta de la foto anterior para eliminaci√≥n
          let previousPhotoPath = '';
          let previousPhotoUrl = operator.photo;

          // ... resto del c√≥digo para procesamiento de imagen ...

      // Verificaci√≥n mejorada de cambios para actualizar
      const hasChanges = Object.keys(updateDto).some(key => {
        const oldValue = operator[key] || operator[key.toLowerCase()];
        const newValue = updateDto[key];
        
        if (key === 'role') {
          // Comparaci√≥n especial para el campo 'role'
          const oldRole = operator.role || 'operator';
          return mapRoleToBackend(data.role) !== oldRole;
        }
        
        console.log(`Comparando ${key}: nuevo=${newValue}, original=${oldValue}, ¬ødiferentes?=${newValue !== oldValue}`);
        return newValue !== undefined && newValue !== null && newValue !== oldValue;
      });

      if (!hasChanges && !updateDto.photo) {
        console.log("No se detectaron cambios en los datos");
        toast.info("No se detectaron cambios para guardar");
        setIsLoading(false);
        return;
      }

      // Limpiar DTO antes de enviar (eliminar campos undefined/null/vac√≠os)
      Object.keys(updateDto).forEach(key => {
        if (updateDto[key] === undefined || updateDto[key] === null || updateDto[key] === '') {
          delete updateDto[key];
        }
      });

      console.log("DTO final para actualizar:", updateDto);

      try {
        console.log("Preparando actualizaci√≥n del operador...");
        
        // Separar y registrar los cambios espec√≠ficos que estamos haciendo
        const originalOperator = { ...operator };
        console.log("VALORES ORIGINALES:", {
          firstName: originalOperator.firstName,
          lastName: originalOperator.lastName,
          email: originalOperator.email,
          role: originalOperator.role,
          status: originalOperator.status,
          phone: originalOperator.phone,
          branch_id: originalOperator.branchReference,
          type_operator_id: originalOperator.type_operator_id
        });
        
        console.log("NUEVOS VALORES:", {
          firstName: data.firstName,
          lastName: data.lastName,
          email: data.email,
          role: mapRoleToBackend(data.role),
          status: data.status,
          phone: data.phone,
          branch_id: data.branch_id,
          type_operator_id: data.type_operator_id
        });
        
        // Construir DTO completo con todos los campos necesarios
        const specialUpdateDto: any = {
          // Campos obligatorios
          email: data.email,
          firstName: data.firstName,
          lastName: data.lastName,
          
          // Campos adicionales importantes
          role: mapRoleToBackend(data.role),
          status: data.status,
          phone: data.phone,
          branch_id: data.branch_id,
          type_operator_id: data.type_operator_id,
          
          // Imagen si hay una nueva
          _imageData: selectedImage && selectedImage !== operator.photo ? selectedImage : undefined
        };
        
        // Si no hay una nueva imagen pero hay una existente, mantener la URL actual
        if (!specialUpdateDto._imageData && operator.photo) {
          // Usar la versi√≥n p√∫blica de la URL (sin token de firma) para evitar problemas de validaci√≥n @IsUrl
          let photoUrl = operator.photo;
          if (photoUrl.includes('?token=')) {
            photoUrl = photoUrl.split('?token=')[0];
          }
          specialUpdateDto.photo = photoUrl;
        }
        
        // Asegurarse de que se incluye el rol correcto
        const newMappedRole = mapRoleToBackend(data.role);
        const allowedBackendRoles = ['admin', 'manager', 'staff', 'guest', 'Contador', 'gerente_de_sucursal', 'programador'];
        
        // Verificar si el rol es v√°lido y actualizar si es necesario
        if (!allowedBackendRoles.includes(newMappedRole)) {
          console.warn(`‚ö†Ô∏è El rol mapeado "${newMappedRole}" no es v√°lido para el backend`);
          
          // Si el operador ya tiene un rol v√°lido, usarlo
          if (allowedBackendRoles.includes(operator.role)) {
            specialUpdateDto.role = operator.role;
            console.log(`üëë Usando rol actual del operador: "${operator.role}"`);
          }else {
            // Valor seguro por defecto
            specialUpdateDto.role = 'staff';
            console.log('üëë Usando rol seguro por defecto: "staff"');
          }
        }else {
          console.log(`üëë Rol "${newMappedRole}" es v√°lido para el backend`);
          specialUpdateDto.role = newMappedRole;
        }
        
        console.log("DTO especial final para actualizaci√≥n:", specialUpdateDto);
        
        // Usar el m√©todo especializado del servicio
        const updatedOperator = await OperatorsService.updateOperatorWithPhoto(
          operator.operatorId, 
          specialUpdateDto
        );
        
        console.log("Operador actualizado con √©xito:", updatedOperator);
        
        // Mostrar notificaci√≥n de √©xito
        toast.success("Operador actualizado correctamente", {
          duration: 3000
        });
        
        // Ejecutar callback si existe
        if (onSave) {
          onSave(updatedOperator);
        }
        
        // Cerrar el di√°logo
        onOpenChange(false);
        
        // Recargar la p√°gina para mostrar los cambios
        setTimeout(() => {
          window.location.reload();
        }, 1500);
        
      }catch (error) {
        console.error("Error al actualizar:", error);
        toast.error(`Error al actualizar: ${error instanceof Error ? error.message : 'Error desconocido'}`);
      }finally {
        setIsLoading(false);
      }
    }catch (error) {
      console.error("Error general en onSubmit:", error);
      toast.error(`Error al guardar: ${error instanceof Error ? error.message : 'Error desconocido'}`);
    }
  };

  // Cargar vista previa de la imagen al iniciar
  useEffect(() => {
    if (operator.photo) {
      setImagePreview(operator.photo);
    }
  }, [operator.photo]);

  return (
    <Dialog open={open}onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[600px] p-0 overflow-hidden bg-white dark:bg-gray-900">
        <DialogHeader className="px-6 pt-6 pb-4 border-b border-gray-100 dark:border-gray-800">
          <DialogTitle className="text-2xl font-semibold text-gray-900 dark:text-gray-100 flex items-center gap-2">
            <div className={`p-2 rounded-md bg-gradient-to-br ${roleColors[form.getValues().role || "Operator"]}`}>
              <PersonIcon className="h-5 w-5 text-white" />
            </div>
            Editar Operador
          </DialogTitle>
          <DialogDescription className="text-gray-500 dark:text-gray-400">
            Actualiza la informaci√≥n del operador en el sistema.
          </DialogDescription>
        </DialogHeader>
        
        {isDataLoading ? (
          <div className="py-12 px-6">
            <div className="space-y-4">
              <div className="flex justify-center items-center">
                <Skeleton className="h-16 w-16 rounded-full" />
              </div>
              <Skeleton className="h-10 w-full" />
              <Skeleton className="h-10 w-full" />
              <Skeleton className="h-10 w-full" />
              <div className="grid grid-cols-2 gap-4">
                <Skeleton className="h-10 w-full" />
                <Skeleton className="h-10 w-full" />
              </div>
            </div>
          </div>
        ) : (
        <div className="px-6 pb-6">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)}className="space-y-6">
              {currentStep === 1 && (
                <motion.div
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 20 }}
                  className="space-y-4"
                >
                    {/* Visualizador de imagen y cargador */}
                    <div className="flex flex-col items-center space-y-3 pt-2 pb-4">
                      <div className="relative">
                        <Avatar className="h-24 w-24 border-2 border-gray-200 dark:border-gray-700">
                          {imagePreview ? (
                            <AvatarImage src={imagePreview}alt={`${form.getValues().firstName} ${form.getValues().lastName}`} />
                          ) : (
                            <AvatarFallback className="bg-gray-100 dark:bg-gray-800 text-gray-500 dark:text-gray-400 text-xl">
                              {form.getValues().firstName?.charAt(0) || ''}{form.getValues().lastName?.charAt(0) || ''}
                            </AvatarFallback>
                          )}
                        </Avatar>
                        <Button
                          type="button"
                          variant="outline"
                          size="icon"
                          className="absolute -bottom-2 -right-2 h-8 w-8 rounded-full bg-white dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 border border-gray-200 dark:border-gray-700"
                          onClick={() => fileInputRef.current?.click()}
                        >
                          <UploadIcon className="h-4 w-4" />
                        </Button>
                      </div>
                      <input 
                        type="file" 
                        accept="image/*" 
                        ref={fileInputRef}
                        onChange={handleImageChange}
                        className="hidden" 
                      />
                      
                      {selectedImage && (
                        <div className="flex items-center gap-2">
                          <span className="text-sm text-gray-500 dark:text-gray-400">
                            Imagen seleccionada
                          </span>
                          <Button 
                            type="button"
                            variant="ghost" 
                            size="icon" 
                            className="h-6 w-6 text-gray-500 hover:text-red-500"
                            onClick={resetImage}
                          >
                            <Cross2Icon className="h-3 w-3" />
                          </Button>
                        </div>
                      )}
                    </div>
                    
                  <div className="grid grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="firstName"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-700 dark:text-gray-300 flex items-center gap-1.5">
                            <PersonIcon className="h-3.5 w-3.5 text-gray-500 dark:text-gray-400" />
                            Nombre
                          </FormLabel>
                          <FormControl>
                            <Input placeholder="Nombre" {...field}className="border-gray-300 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={form.control}
                      name="lastName"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-700 dark:text-gray-300 flex items-center gap-1.5">
                            <PersonIcon className="h-3.5 w-3.5 text-gray-500 dark:text-gray-400" />
                            Apellido
                          </FormLabel>
                          <FormControl>
                            <Input placeholder="Apellido" {...field}className="border-gray-300 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                  
                  <FormField
                    control={form.control}
                    name="email"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="text-gray-700 dark:text-gray-300 flex items-center gap-1.5">
                          <EnvelopeClosedIcon className="h-3.5 w-3.5 text-gray-500 dark:text-gray-400" />
                          Correo electr√≥nico
                        </FormLabel>
                        <FormControl>
                          <Input placeholder="correo@ejemplo.com" {...field}className="border-gray-300 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  
                  <FormField
                    control={form.control}
                    name="phone"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="text-gray-700 dark:text-gray-300 flex items-center gap-1.5">
                          <MobileIcon className="h-3.5 w-3.5 text-gray-500 dark:text-gray-400" />
                          Tel√©fono
                        </FormLabel>
                        <FormControl>
                          <Input placeholder="+507 6123-4567" {...field}className="border-gray-300 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  
                  <div className="grid grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="role"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-700 dark:text-gray-300 flex items-center gap-1.5">
                            <IdCardIcon className="h-3.5 w-3.5 text-gray-500 dark:text-gray-400" />
                            Rol
                          </FormLabel>
                          {operator.role === "programador" && (
                            <div className="text-xs text-amber-600 dark:text-amber-400 mb-1 font-medium">
                              ‚ö†Ô∏è Este operador tiene un rol especial (Programador). Cambiar el rol podr√≠a afectar sus permisos.
                            </div>
                          )}
                          <Select 
                            onValueChange={field.onChange}
                            defaultValue={field.value}
                          >
                            <FormControl>
                              <SelectTrigger className="border-gray-300 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100">
                                <SelectValue placeholder="Seleccionar rol" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent className="dark:bg-gray-800 dark:border-gray-700">
                              <SelectItem value="Admin" className="dark:text-gray-100 dark:focus:bg-gray-700">Administrador (admin)</SelectItem>
                              <SelectItem value="Manager" className="dark:text-gray-100 dark:focus:bg-gray-700">Gerente (manager)</SelectItem>
                              <SelectItem value="Branch_Manager" className="dark:text-gray-100 dark:focus:bg-gray-700">Gerente de Sucursal</SelectItem>
                              <SelectItem value="Operator" className="dark:text-gray-100 dark:focus:bg-gray-700">Operador (staff)</SelectItem>
                              <SelectItem value="Programador" className="dark:text-gray-100 dark:focus:bg-gray-700">Programador</SelectItem>
                            </SelectContent>
                          </Select>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    
                    <FormField
                      control={form.control}
                      name="status"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-700 dark:text-gray-300 flex items-center gap-1.5">
                            <InfoCircledIcon className="h-3.5 w-3.5 text-gray-500 dark:text-gray-400" />
                            Estado
                          </FormLabel>
                          <Select 
                            onValueChange={field.onChange}
                            defaultValue={field.value}
                          >
                            <FormControl>
                              <SelectTrigger className="border-gray-300 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100">
                                <SelectValue placeholder="Seleccionar estado" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent className="dark:bg-gray-800 dark:border-gray-700">
                              <SelectItem value="active" className="dark:text-gray-100 dark:focus:bg-gray-700">Activo</SelectItem>
                              <SelectItem value="inactive" className="dark:text-gray-100 dark:focus:bg-gray-700">Inactivo</SelectItem>
                              <SelectItem value="suspended" className="dark:text-gray-100 dark:focus:bg-gray-700">Suspendido</SelectItem>
                            </SelectContent>
                          </Select>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                  
                  <div className="flex justify-between pt-2">
                    <Button 
                      type="button" 
                      variant="outline" 
                      onClick={() => onOpenChange(false)}
                      className="border-gray-300 dark:border-gray-700 dark:text-gray-300 dark:hover:bg-gray-800"
                    >
                      Cancelar
                    </Button>
                    <Button 
                      type="button" 
                      onClick={() => setCurrentStep(2)}
                      className={`bg-${themeColor}-600 hover:bg-${themeColor}-700 dark:bg-${themeColor}-700 dark:hover:bg-${themeColor}-800`}
                    >
                      Siguiente
                    </Button>
                  </div>
                </motion.div>
              )}
              
              {currentStep === 2 && (
                <motion.div
                  initial={{ opacity: 0, x: 20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: -20 }}
                  className="space-y-4"
                >
                  <div className="grid grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="branch_id"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-700 dark:text-gray-300 flex items-center gap-1.5">
                            <HomeIcon className="h-3.5 w-3.5 text-gray-500 dark:text-gray-400" />
                            Sucursal
                          </FormLabel>
                          <Select 
                            onValueChange={field.onChange}
                            defaultValue={field.value}
                          >
                            <FormControl>
                              <SelectTrigger className="border-gray-300 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100">
                                <SelectValue placeholder="Seleccionar sucursal" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent className="dark:bg-gray-800 dark:border-gray-700">
                              {branches.map((branch) => (
                                <SelectItem key={branch.id}value={branch.id} className="dark:text-gray-100 dark:focus:bg-gray-700">
                                  {branch.name}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    
                    <FormField
                      control={form.control}
                      name="type_operator_id"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-gray-700 dark:text-gray-300 flex items-center gap-1.5">
                            <IdCardIcon className="h-3.5 w-3.5 text-gray-500 dark:text-gray-400" />
                            Tipo de operador
                          </FormLabel>
                            <div className="relative">
                              {currentOperatorType && (
                                <div className="absolute right-0 -top-5 z-10">
                                  <span className="text-xs bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 px-1.5 py-0.5 rounded-full">
                                    Actual: {currentOperatorType}
                                  </span>
                                </div>
                              )}
                          <Select 
                                onValueChange={(value) => {
                                  field.onChange(value);
                                  const selectedType = operatorTypes.find(type => type.id === value);
                                  if (selectedType) {
                                    setCurrentOperatorType(selectedType.name);
                                  }
                                }}
                            defaultValue={field.value}
                          >
                            <FormControl>
                              <SelectTrigger className="border-gray-300 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100">
                                <SelectValue placeholder="Seleccionar tipo" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent className="dark:bg-gray-800 dark:border-gray-700">
                              {operatorTypes.map((type) => (
                                <SelectItem key={type.id}value={type.id} className="dark:text-gray-100 dark:focus:bg-gray-700">
                                  {type.name}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                            </div>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                  
                  <div className="flex justify-between pt-2">
                    <Button 
                      type="button" 
                      variant="outline" 
                      onClick={() => setCurrentStep(1)}
                      className="border-gray-300 dark:border-gray-700 dark:text-gray-300 dark:hover:bg-gray-800"
                    >
                      Anterior
                    </Button>
                    <Button 
                      type="submit"
                      disabled={isLoading}
                      className={`bg-${themeColor}-600 hover:bg-${themeColor}-700 dark:bg-${themeColor}-700 dark:hover:bg-${themeColor}-800`}
                    >
                      {isLoading ? (
                        <>
                          <ReloadIcon className="mr-2 h-4 w-4 animate-spin" />
                          Guardando...
                        </>
                      ) : (
                        <>
                          <CheckIcon className="mr-2 h-4 w-4" />
                          Guardar cambios
                        </>
                      )}
                    </Button>
                  </div>
                </motion.div>
              )}
            </form>
          </Form>
          
          <DialogClose className="hidden" />
        </div>
        )}
      </DialogContent>
    </Dialog>
  );
}
